# 第1章 计算机系统概述

- [ ] 多任务操作系统的概念、特点是什么？【P3】
	- **定义：** 多任务操作系统是指允许**两个或两个以上**的用户程序在同一时间段内装入内存，并**并发**（Concurrent）执行的操作系统。
		- **表面上（宏观）**：用户感觉多个程序是**同时**在这个电脑上运行的（比如你一边听歌，一边写 Word，后台还在下载文件）。		    
		- **实际上（微观）**：		    
		    - **单核 CPU**：在极短的时间内（毫秒级），CPU 在不同的任务之间快速切换（时间片轮转）。因为切换速度太快，骗过了人的眼睛。	        
		    - **多核 CPU**：可以实现真正的物理**并行（Parallel）**，即不同的核跑不同的任务。
	- 特点：
		- 并发性 (Concurrency) —— 最核心特征
			- **定义**：指两个或多个事件在**同一时间间隔内**发生。
			- **考点辨析（并发 vs 并行）**：
			    - **并发 (Concurrent)**：**宏观上同时，微观上交替**。这是操作系统的特征。
			    - **并行 (Parallel)**：**宏观和微观上都是同时**。这通常需要多核 CPU 或多台机器支持。
		- 共享性 (Sharing)			
			- **定义**：系统中的资源（硬件/软件）可供内存中多个并发执行的进程共同使用。		    
			- **两种共享方式**：			    
			    - **互斥共享**：一段时间内只允许一个进程访问（如：打印机、磁带机）。对应**临界资源**。			        
			    - **同时共享**：宏观上同时访问，微观上交替访问（如：磁盘文件、只读数据）。
		- 虚拟性 (Virtuality)			
			- **定义**：把一个物理上的实体变为若干个逻辑上的对应物。			    
			- **两大技术（考点）**：			    
			    - **时分复用 (Time Division Multiplexing)**：虚拟处理器技术。通过多道程序设计，让一个物理 CPU 变身为多个逻辑 CPU，每个进程都觉得自己独占 CPU。      
			    - **空分复用 (Space Division Multiplexing)**：虚拟存储器技术。利用磁盘空间扩充内存，让 4GB 的物理内存跑出 16GB 的效果。			
		- 4. 异步性 (Asynchrony)			
			- **定义**：在多道程序环境下，允许多个进程并发执行，但由于资源有限，进程的执行不是一气呵成的，而是“走走停停”的。			    
			- **结果**：进程以不可预知的速度向前推进。
- [ ] 系统调用的过程是怎么样的？【P18】
	![[系统调用的过程.png|656x358]]
- [ ] 批处理系统的特点是什么？【P8】
- [ ] 内部异常的三大分类是什么？每种分类的特点、处理流程和返回位置分别是什么？【P17】
	- 故障 (Fault) —— 软中断
		- **特点**：由指令执行引起的“可修复”错误。
		- **典型例子**：
		    - **缺页异常 (Page Fault)**
		    - **TLB缺失**（在某些架构下是软件处理的异常）。
		    - 除数为0、非法操作码。
		- **处理流程**：检测到 $\rightarrow$ 调出处理程序 $\rightarrow$ 修复错误（如把页调入内存）。
		- **返回位置**：**重新执行当前指令**。
	- 陷阱 (Trap) / 自陷 —— 软中断
		- **特点**：**预先安排好的**、**人为故意**触发的异常。它是从用户态进入核心态的唯一“正规”门户。
		- **典型例子**：
		    - **系统调用 (System Call)**：如执行 `int 0x80` 或 `syscall` 指令。
		    - **断点调试**。		        
		- **处理流程**：执行陷阱指令 $\rightarrow$ 陷入内核 $\rightarrow$ 也就是所谓的“软中断”。		    
		- **返回位置：执行下一条指令。
	- 终止 (Abort) —— 硬中断
		- **特点**：发生了**不可恢复**的致命错误。	    
		- **典型例子**：		    
		    - 硬件故障（控制器出错）。	        
		    - 存储器校验错（ECC无法纠正）。        
		- **处理流程**：直接强行停止程序，OS把该进程杀掉。		    
		- **返回位置**：**无**（不返回，直接通过）。
- [ ] 外部中断的具体分类和触发事件有哪些？【P17】
	- 可屏蔽中断：
		这是最常见的外部中断。CPU 可以通过设置状态寄存器（如 x86 的 EFLAGS 里的 IF 位）来决定“听还是不听”。如果关中断（CLI），CPU 就会暂时忽略它。
		- **/O 设备中断**：    
		    - **键盘/鼠标输入**：当你按下一个键，键盘控制器发送中断，CPU 暂停去读字符。		        
		    - **打印机/扫描仪**：打印机缺纸或打印完成时发送信号。
		    - **网卡 (NIC)**：当数据包到达时，网卡通知 CPU “有快递到了，快来处理”。		        
		    - **磁盘/硬盘**：当 DMA 传输完成，或者读写操作结束时，硬盘控制器通知 CPU。		        
		- **时钟中断 (Clock Interrupt)** —— **最重要！**		    
		    - 由外部的定时器/计数器硬件产生。	        
		    - **作用**：每隔固定的时间片（如 10ms）“打断”一下 CPU。这是**操作系统实现多任务并发、时间片轮转调度**的基础。
	- 不可屏蔽中断 (Non-Maskable Interrupt, NMI)
		这是极其紧急的情况，CPU **不能忽视**，必须立即处理，哪怕当前是在关中断状态下。
		- **硬件故障**：		    
		    - **电源掉电**：电源模块检测到电压不稳，即将断电，通知 CPU 赶紧保存现场。		        
		    - **内存校验错误**：内存条坏了或数据传输出错（奇偶校验错）。		        
		    - **总线错误**。		        
		- **紧急按钮**：某些服务器或嵌入式设备上的物理 Reset 按钮。
- [ ] 操作系统如何避免用户程序直接访问外设？
	提供系统调用。
- [ ] 不同的操作系统为应用程序提供了统一的系统调用接口吗？
	没有。不同操作系统的设计理念、架构、底层实现以及发展历程存在差异。
# 第2章 进程与线程
- [ ] 管道通信的基本概念和特点是什么？【P43】
	- 基本概念：管道通信（Pipe）是一种最古老的进程间通信（IPC）方式，本质是内核在内存中维护的一个**固定大小的缓冲区**。
	- 特点：
		- **半双工通信（Half-duplex）：** 数据只能单向流动（一个进程写，一个进程读）。若需双向通信，通常需要建立两个管道。
		- **先进先出（FIFO）：** 数据以**字节流**形式传输，遵循写入顺序，无格式限制。
		- **文件接口：** 在 Linux/Unix 中被视为一种特殊文件，通过标准的 `read()` 和 `write()` 系统调用进行访问。
		- **固定缓冲区：** 管道大小有限（通常为内存的一页，如 4KB），写满会阻塞，读空也会阻塞。
		- **同步与互斥：** 内核自动处理进程间的同步问题（**写满则等，读空则挂**）和互斥问题（同一时刻只能有一个进程操作）。
- [ ] 进程和线程最本质的区别是什么（定义级）？【P44】
	- **进程 (Process)**：是 **资源分配** 的基本单位。
	- **线程Thread)**：是 **调度**（独立运行）的基本单位。
- [ ] 如果一个“用户级线程 (ULT)”发起系统调用被阻塞，整个进程内的其他线程还能运行吗？【P47】
	**不能**。整个进程（包括其他所有线程）都会被阻塞。
- [ ] CPU调度算法都有哪些？它们都是怎么运作的？【P71】
	- FCFS调度算法
	- SJF调度算法；SRTN（最短剩余时间优先）算法
	- 高响应比优先调度算法
		- $响应比R_{P}=\frac{等待时间+要求服务时间}{要求服务时间}$
	- 优先级调度算法
	- 时间片轮转调度算法
	- 多级队列调度算法
		- 在系统中设置多个就绪队列，每个队列可实施不同的调度算法。
	- 多级反馈队列调度算法
		- 第$1\sim(n-1)$级队列：FIFO
		- 第$n$级队列：时间片轮转
	- 基于公平原则的调度算法
		- 保证调度算法
		- 公平分享调度算法
- [ ] 可以进行CPU调度的事件或时机有哪些？【P68】
	- 创建新进程后；
	- 进程正常结束或异常终止后；
	- 当进程因I/O请求、信号量操作或其他原因被阻塞时；
	- 当I/O设备准备就绪后，发出I/O中断，原先等待I/O的进程从阻塞态变为就绪态。
- [ ] 不能进行进程的调度和切换的情况有哪些？【P68】
	- 在处理中断的过程中；
	- 需要完全屏蔽中断的原子操作过程中;
	- 进程在操作系统内核程序的临界区中。
- [ ] 周转时间、带权周转时间、等待时间、响应时间的概念是什么？【P69】
	- $周转时间=作业完成时间-作业提交时间$
	- $带权周转时间= \frac{作业周转时间}{作业实际运行时间}\geq1$
	- 等待时间：指进程处于等待CPU的时间之和。
	- 响应时间：指从用户提交请求到系统首次产生响应所用的时间。
- [ ] 实现临界区互斥必须遵循的准则是什么？【P99】
	- 空闲让进
	- 忙则等待
	- 有限等待
	- 让权等待（原则上应该遵循，但非必须）：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。
- [ ] 实现临界区互斥的基本方法有哪些？【P99】
	- 软件实现方法
		1. 单标志法 (Single Flag)
			- **机制**：设置一个公共变量 `turn`，轮流进入。
			- **缺点**：**强制轮替**。如果 A 不进，B 也进不去。违背了“空闲让进”原则。
	    2. 双标志先检查法 (Double Flag, Check First)
			- **机制**：先检查对方是否想进，再标记自己想进。
			- **缺点**：**忙则可能全进**。检查和上锁不是原子操作，可能两个进程同时检测到对方没锁，然后同时进入。违背了“忙则等待”（互斥性）原则。
		3. 双标志后检查法 (Double Flag, Check Later)
			- **机制**：先标记自己想进，再检查对方是否想进。
		    - **缺点**：**饥饿/死锁**。两个人都举手了，互相谦让，谁也进不去。
	    4. 皮特森算法 (Peterson's Algorithm)
			- **机制**：结合了双标志和单标志（谦让）的思想。设置 `flag[]` 表示意愿，设置 `turn` 表示谦让。
			    - 核心代码逻辑：`flag[i]=true; turn=j; while(flag[j] && turn==j);`
			- **特点**：
			    - **优点**：完美解决了互斥问题，且不会死锁。
			    - **缺点**：**忙等（Busy Waiting）**。进程进不去时，会在 while 循环里空转，消耗 CPU 时间。**违背了“让权等待”原则。**
	- 硬件实现方法
		1. 中断屏蔽方法 (Disabling Interrupts)
			- **机制**：进入临界区前关中断（`cli`），出临界区后开中断（`sti`）。	
			- **特点**：			    
			    - **优点**：简单、高效。因为CPU切换进程主要靠中断，关了中断就没人能抢占你了。			        
			    - **缺点**：			        
			        1. **不适用于多处理器 (MP)**：关中断只能关当前CPU的，其他CPU照样访问内存。
			        2. **危险**：把关中断权限给用户进程极其危险。
			        3. **限制**：只适用于操作系统内核进程。
		2. Test-And-Set (TSL/TS 指令)
			- **机制**：硬件提供一条原子指令（读出旧值并设为 true），不可被中断。
			- **特点**：			    
			    - **优点**：实现简单，**适用于多处理器**环境。			        
			    - **缺点**：**忙等**（进不去的进程会一直不断地执行 TSL 指令查询），无法实现“让权等待”，浪费 CPU。
        3. Swap 指令 (Exchange 指令)
			- **机制**：原子性地交换两个变量的值。	
			- **特点**：			    
			    - 与 TSL 指令类似，优点是简单、适用多处理器；缺点依然是**忙等**。
- [x] 死锁预防、死锁避免、死锁检测的区别是什么？【P149】
	- 死锁预防：通过破坏死锁的必要条件来让死锁不可能发生。
	- 死锁避免：避免进入易发生死锁的状态。不会限制用户申请资源的顺序（死锁预防中的“顺序资源分配法”会）。
	- 死锁检测：定期检测死锁是否已发生。
- [x] 安全状态和不安全状态代表什么？
	- 安全状态代表一定不会发生死锁。
	- 不安全状态未必就会出现死锁。![[不安全状态与死锁的关系.png|258x311]]
- [ ] 管程的基本特性有哪些？【P112】
	- 模块化与封装性：
		- 它把**共享数据结构**、对该数据结构进行操作的**一组过程（函数）**、以及**初始化代码**封装在一起，组成了一个模块。
		- 管程内部的数据结构是**私有**的（Private）。管程外部的进程**不能直接访问**管程内部的数据结构。外部进程想要修改共享数据，只能**调用管程内部提供的过程（函数）**。
	- 自动互斥：
		- 管程每一次只允许一个进程进入管程执行内部过程。
		- 这种互斥特性是由**编译器/语言本身**负责实现的，而**不是**由程序员写的代码实现的。
	- 同步机制：
		- 管程引入了**条件变量 (Condition Variables)**。
			- `x.wait()`：当条件不满足时，进程调用此操作，将自己阻塞，并**释放管程的互斥权**（这点很重要，不然别人进不来，死锁了）。
			- `x.signal()`：当条件满足时，唤醒一个在 `x` 上等待的进程。
		- **区别**：管程的 `signal` 和信号量的 `V` 操作不同。
			- 信号量 `V`：一定会使信号量+1。
			- 管程 `signal`：如果此时没有进程在等待，`signal` 操作**不起任何作用**（不会像信号量那样累积）。
	- 被动性：
		- 管程是**资源管理模块**，它是被动的；进程是**执行实体**，它是主动的。
# 第3章 内存管理
- [ ] 连续分配管理方式中的各种动态分区分配算法有什么特点？【P183】
- [x] TLB是什么？其物理位置是什么？【P187】
	- 转换旁路缓冲器（Translation Lookaside Buffer），俗称快表，专门用来存放“最近用过的页表项”的硬件高速缓存。
	- TLB属于 **MMU** 的一部分。 在现代计算机中，MMU 是集成在 **CPU 芯片**内部的。
- [ ] 页面置换算法有哪些？它们都是如何工作的？【王道P218】
	- 最佳（OPT）替换算法：选择淘汰以后永不使用的页面，或者是在最长时间内不再被访问的页面。
	- 先进先出（FIFO）算法：淘汰最早进入内存的页面
	- 最近最久未使用（LRU）算法
	- 时钟（CLOCK）置换算法
		- 简单的CLOCK置换算法
		- 改进型的CLOCK置换算法
			- 淘汰页的次序：A=0，M=0；A=0，M=1；A=1，M=0；A=1，M=1；（00，01，10，11）
			- 优先调出最近未被访问的页面以减少缺页率。在访问情况相同时，优先调出未被修改的页面，以减少I/O开销，因为未被修改的页面不需要写回磁盘。
			- 第一次扫描寻找A=0，M=0，不改变访问位A；
			- 第二次扫描寻找A=0，M=1，将扫描过的页面的访问位置0；
			- 第三次扫描寻找A=0，M=0，不改变访问位A；
			- 第四次扫描寻找A=0，M=1，将扫描过的页面的访问位置0；
- [x] 内存分配策略中，操作系统采用固定分配局部置换说明什么呢？
	- 固定分配：操作系统在进程**开始运行前**（或刚开始时），就根据某种策略（例如平均分配、按进程大小比例分配等）为它**分配了固定数量的物理页框**。
	- 局部置换：当进程发生缺页时，它**只能**在自己**当前拥有**的物理页框中选择一个来换出。这个操作只会改变该物理页框的**内容**（旧的虚拟页被换出，新的虚拟页被换入），**不会**改变该进程所拥有的物理页框的**集合**。
- [ ] 抖动如何处理呢？
	- 利用局部置换策略：局部置换策略通过**限制受害页面的选择范围”**，防止了抖动在进程间传播，并使得操作系统能更准确地识别出是哪个进程缺少内存。
	- 利用工作集概念：工作集模型为系统提供了一个明确的“准绳”。系统不再是“盲目地”把进程塞进内存，而是**确保只有那些内存需求能被满足的进程才能进入“活动”状态**。这从根本上防止了因内存过度分配（Over-committing）而导致的抖动。
	- 适当挂起进程，释放内存空间。
- [ ] 工作集【P222】
- [ ] 在虚拟内存管理中，地址变换机构将逻辑地址变换为物理地址，形成该逻辑地址的阶段是哪一阶段？
	链接
- [ ] 在请求分页系统中，决定有效访存时间 (EAT)的核心公式是什么？【P224】
	$$EAT = (1 - p) \times t_{mem} + p \times t_{fail}$$

	- $p$：**缺页率** (Page Fault Rate)。	    
	- $t_{mem}$：**内存访问时间** (Memory Access Time)。	    
	- $t_{fail}$：**缺页处理时间** (Page Fault Time)。$t_{fail} = \text{CPU处理开销} + \text{磁盘I/O时间} + \text{重启进程开销}$
# 第4章 文件管理
- [ ] 文件控制块包含哪些信息？【P254】
	- 基本信息：文件名、文件的物理信息、文件的逻辑结构、文件的物理结构等。
	- 存取控制信息：包括文件主的存取权限、批准用户的存取权限以及一般用户的存取权限。
	- 使用信息：如文件使用时间、上次使用时间等。
- [ ] 在多个进程可以同时打开文件的操作系统中，整个系统表和每个进程表的内容有什么不同？【P256】
	- 每个进程表：
		- **当前读写指针 (Read/Write Pointer / Offset)**：		           
		    - 进程 A 读到了第 100 页，进程 B 读到了第 1 页。他们互不干扰。因此，读写位置必须存在进程私有的表里（或者指向一个私有的打开实例）。	        
		- **访问权限 (Access Mode)**：		    
		    - 进程 A 是以“只读”方式打开的，进程 B 是以“读写”方式打开的。这个模式是针对当次打开操作的。		        
		- **系统表索引/指针**：		    
		    - 指向“系统打开文件表”中对应条目的指针。它告诉系统：“我想读的文件，具体的物理信息在系统表的那一行”。
	- 整个系统表：
		- **打开计数器 (Open Count)**：	    
		    - 记录当前有多少个进程打开了这个文件。	        
		    - 当进程 A 打开文件，Count++；进程 B 打开，Count++。	        
		    - 当进程关闭文件 (Close) 时，Count--。只有当 **Count = 0** 时，系统才会真正从内存中删除这个条目（释放 FCB 缓存）。        
		- **文件控制块 (FCB) 的副本 / Inode 信息**：    
		    - 包含文件的**物理地址**（在磁盘的哪个块）、**文件大小**、**文件属性**（创建时间、所有者）。        
		    - 这些信息对于所有打开该文件的进程来说，都是**一样**的，所以只需要在系统表里存一份，大家共用。
- [x] 文件共享，硬链接和软链接的链接计数背后的原理图是什么样的？
	![[文件共享中的硬链接&软连接.webp]]
- [x] 位示图为“0”表示什么？为“1”表示什么？【王道P298】
	“0”表示对应盘块空闲；
	“1”表示已分配。
- [x] 只要完成了文件打开open()调用，后面再使用read()、write()、Lseek()、close()等文件操作的系统调用，使用什么参数找到文件？【P257】
	不再使用文件名，而使用文件描述符。
- [ ] 磁盘存储空间分配方式有哪些？【P259】
	- 连续分配 (Contiguous Allocation)
		- **原理**：文件占用磁盘上**连续**的几个物理块。就像在电影院买了一排连座的票。 		    
		- **记录方式**：FCB（文件控制块）中只需要记录 **起始块号** 和 **长度**。		    
		- **优点**：		    
		    - **速度最快**：支持**顺序访问**和**直接访问（随机访问）**。磁头移动距离最短。		        
		- **缺点**：		    
		    - **产生外部碎片**：磁盘上会有很多小的空闲块用不上（类似动态分区分配）。		        
		    - **文件扩展困难**：如果你后面有人坐了，你就没法增加长度了，必须整体搬家。
	- 链接分配 (Linked Allocation)
		文件离散地分布在磁盘中，通过指针连起来。分为两种：	
		- **隐式链接 (Implicit Linking)**：		    
		    - 每个盘块里藏一个指向下一块的指针。像单链表。	        
		    - **缺点**：**不支持随机访问**（想看第 10 块，必须从第 1 块走到第 9 块）；指针占用数据空间。		        
		- **显式链接 (Explicit Linking) ——  FAT 技术**：		    
		    - 把所有的指针提取出来，放在内存的一张表中，叫 **文件分配表 (FAT, File Allocation Table)**。		        
		    - **优点**：**支持随机访问**（查内存里的表很快），且不浪费盘块空间。		        
		    - **缺点**：FAT 表需要占用较大的内存空间。
	- 索引分配 (Indexed Allocation)
		- **原理**：为每个文件建立一个 **索引块 (Index Block)**，里面存的是一张表，记录了该文件所有的物理块号。  		    
		- **优点**：**支持随机访问**，且**没有外部碎片**。		    
		- **缺点**：索引块本身会占用额外的磁盘空间。		    
		- **变体（为了支持大文件）**：		    
		    - **链接索引**：一个索引块不够，就用指针连到下一个索引块。		        
		    - **多级索引**：索引块里指的不是数据，而是下一级索引块（类似页表）。		        
		    - **混合索引 (UNIX)**：直接地址 + 一级间接 + 二级间接...
# 第5章 输入/输出管理
- [x] 处理外部中断时，应该由操作系统保存的是什么？【P310】
	- 保存现场（用户可见）：通用寄存器的内容
- [x] 磁盘调度算法具体有哪些？分别是怎么进行调度的？【王道P343】
	- 先来先服务（FCFS）算法
	- <mark style="background: #ADCCFFA6;">最短寻道时间优先（SSTF）算法</mark>
	- 扫描（SCAN）算法
		- 又名电梯调度算法
	- 循环扫描（C-SCAN）算法
		- 磁头只会单向移动来提供服务
- [x] 单缓冲和双缓冲的工作时间的理解与计算
	- 从“对同一缓冲区的访问是互斥的”这一点进行分析。
	- 假定从设备将一块数据输入缓冲区的时间为$T$，操作系统将缓冲区中的数据传送到工作区的时间为$M$，CPU对这一块数据进行处理的时间为$C$。
	- 单缓冲：$\max(C,T)+M$
	- 双缓冲：$\max(C+M,T)$
- [ ] 为什么说“可以使用文件名访问物理设备”？【P325】
	这是现代操作系统（特别是 UNIX/Linux）的一个核心设计哲学：**“一切皆文件”**。
	- 操作系统将 I/O 设备抽象为特殊的文件。	    
	- 用户通过文件名（如 `/dev/tty` 代表终端，`/dev/sda` 代表硬盘）来访问设备，就像访问普通文本文件一样（使用 `read`, `write`, `open` 系统调用）。
- [ ] SPOOLing技术（假脱机技术）【P326】
- [ ] 磁盘逻辑格式化的过程是什么？【P341】
	1. 将磁盘分区（C盘、D盘、......），每个分区由一个或多个柱面组成，每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中。
	2. 对物理分区进行逻辑格式化，将初始的文件系统数据结构存储到磁盘
- [ ] 负责将“簇号”转换为“LBA”的是谁？负责将“LBA”转换为“电信号控制磁臂”的是谁？
	- **簇 $\to$ LBA（逻辑扇区号）**：**操作系统（文件系统）**。   
	- **LBA $\to$ CHS(Cylinder 柱面, Head 磁头, Sector 扇区)**：**磁盘控制器**（配合驱动程序）。
- [ ] 时钟中断服务程序主要负责更新和维护什么？
	1. 维护系统全局时间 (System Time)
		这是最基础的工作。操作系统内核必须知道“现在几点了”以及“系统开机多久了”。
		- **系统滴答计数器 (Tick Counter/Jiffies)**：这是一个全局变量，每发生一次时钟中断，该变量加 1。它是系统计算时间间隔的基础。            
		- **软时钟 / 墙上时间 (Wall Clock Time)**：根据滴答数，更新当前的年、月、日、时、分、秒（即日历时间）。
    2. 维护当前进程的时间片 (Current Process Accounting)
	    这是实现**分时多任务（Time Sharing）**的关键。
	    - **当前进程的剩余时间片 (Time Slice)**：        
	        - ISR 会将当前正在 CPU 上运行的进程（Running 状态）的时间片减 1（或者减去一个 tick 的长度）。
        - **当前进程的 CPU 统计信息**：        
	        - 更新该进程在**用户态**或**核心态**运行的总时间（用于性能分析和记账）。            
	        - _考点_：如果系统支持动态优先级，可能还会根据 CPU 使用情况调整该进程的**优先级**（如 UNIX 的多级反馈队列）。
    3. 维护软定时器与阻塞队列 (Timer & Sleeping Processes)
	    系统中有许多进程调用了 `sleep()` 或设置了超时等待，它们正处于阻塞状态，等待时间到期。
	    - **软定时器链表**：扫描或处理内核中的定时器队列。	        
	    - **倒计时减 1**：对于那些正在执行延时操作的进程，减少它们的剩余等待时间。	        
	    - **唤醒进程**：	        
	        - 如果某进程的等待时间减为 0，ISR 会将其状态从 **阻塞态 (Blocked)** 修改为 **就绪态 (Ready)**。	            
	        - 将其从等待队列移到 **就绪队列** 挂起，等待被调度。     
	4. 触发调度检查 (Scheduling Decision)
		这是时钟中断最重要的后果——决定“政权是否更迭”。
	    - **调度标志位 (Need_Reschedule Flag)**：	        
	        - ISR 会检查当前进程的**剩余时间片**是否已减为 0。	            
	        - **如果时间片用完**：ISR 会置位“调度请求标志”，通知内核在中断返回前进行进程调度（切换到另一个进程）。	            
	        - **如果时间片没用完**：且没有更高优先级进程被唤醒，则直接返回，让当前进程继续跑。上，这些数据结构包括空闲的空间和已分配的空间，以及一个初始为空的目录，建立根目录、对保存空闲磁盘块信息的数据结构进行初始化。
# 其他
- [ ] 多道程序系统相较于单道程序系统的优点有什么？
	- CPU利用率高
	- 系统吞吐量大
	- I/O设备利用率高
- [ ] 时钟中断服务程序主要负责更新和维护什么内容？
	- 维护系统全局时间 (System Time)
	    - **系统滴答计数器 (Tick Counter/Jiffies)**：这是一个全局变量，每发生一次时钟中断，该变量加 1。它是系统计算时间间隔的基础。	        
	    - **软时钟 / 墙上时间 (Wall Clock Time)**：根据滴答数，更新当前的年、月、日、时、分、秒（即日历时间）。        
	- 维护当前进程的时间片 (Current Process Accounting)
	    - **当前进程的剩余时间片 (Time Slice)**：	        
	        - ISR 会将当前正在 CPU 上运行的进程（Running 状态）的时间片减 1（或者减去一个 tick 的长度）。	            
	    - **当前进程的 CPU 统计信息**：	        
	        - 更新该进程在**用户态**或**核心态**运行的总时间（用于性能分析和记账）。	            
	        - _考点_：如果系统支持动态优先级，可能还会根据 CPU 使用情况调整该进程的**优先级**（如 UNIX 的多级反馈队列）。           
	- 维护软定时器与阻塞队列 (Timer & Sleeping Processes)
		系统中有许多进程调用了 `sleep()` 或设置了超时等待，它们正处于阻塞状态，等待时间到期。	  
		- **软定时器链表**：扫描或处理内核中的定时器队列。	        
	    - **倒计时减 1**：对于那些正在执行延时操作的进程，减少它们的剩余等待时间。	        
	    - **唤醒进程**：	        
	        - 如果某进程的等待时间减为 0，ISR 会将其状态从 **阻塞态 (Blocked)** 修改为 **就绪态 (Ready)**。	            
	        - 将其从等待队列移到 **就绪队列** 挂起，等待被调度。            
	- 触发调度检查 (Scheduling Decision)
		这是时钟中断最重要的后果——决定“政权是否更迭”。
	    - **调度标志位 (Need_Reschedule Flag)**：        
	        - ISR 会检查当前进程的**剩余时间片**是否已减为 0。            
	        - **如果时间片用完**：ISR 会置位“调度请求标志”，通知内核在中断返回前进行进程调度（切换到另一个进程）。            
	        - **如果时间片没用完**：且没有更高优先级进程被唤醒，则直接返回，让当前进程继续跑。