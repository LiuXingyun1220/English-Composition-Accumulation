# 原码乘法运算
![[原码乘法的硬件逻辑实现.png]]![[原码乘法的流程.png]]
右移一位为逻辑右移

如果每次根据乘数中的两位来计算位积，则位积的数目会减少一半，因此循环累加次数将减少一半，可以大大提升乘法的运算速度，这种乘法称为**二位乘法**。
# 补码乘法运算
![[补码乘法的硬件逻辑实现.png]]
![[补码乘法的流程.png]]
- **特点**：符号位参与运算，自然形成补码结果。    
- **硬件特殊点**：MQ 寄存器末尾增加一个辅助位 **$y_{n+1}$**（初始为 0）。    
- **移位规则**：**算术右移**（高位补符号位）。
- **循环**：    
    - 进行 $n$ 轮“判断-加法-移位”。        
    - **最后一步（第 $n+1$ 步）**：只做加法，**不再移位**。        
- **口诀**：**“后减前”**（$y_{n+1} - y_n$）。如果是 1，加X；如果是 -1，减X。
# 原码除法运算
## 恢复余数法
![[原码除法的恢复余数法.png]]
- **符号**：符号位单独异或处理。     
- **流程**：         
    1. **默认上商 1**：先做减法 `ACC = ACC - |X|`（即 `+ [-|X|]补`）。        
    2. **判断余数符号**：        
        - **若余数为正**：说明够减，商 1 正确。**MQ 末位上 1**。          
        - **若余数为负**：说明不够减，商 1 错了。**MQ 末位上 0**，并**恢复余数**（`ACC = ACC + |X|`）。            
    3. **移位**：`ACC` 和 `MQ` 连起来**逻辑左移** 1 位。        
    4. **循环**：重复 $n$ 次。        
- **缺点**：若不够减，需要做两次加法（一次减，一次加回），速度慢。
## 不恢复余数法（也称加减交替法）
![[原码除法的不恢复余数法.png]]
- **特点**：根据余数的符号决定下一步是“加”还是“减”。    
- **流程**：    
    1. **看余数 ($R$) 符号**：        
        - 若 $R$ 为正：商上 1，**左移**，下一次 **减除数**。            
        - 若 $R$ 为负：商上 0，**左移**，下一次 **加除数**。            
    2. **循环**：重复 $n$ 次。        
    3. **最后一步修正**：        
        - 如果最后一步得到的余数是负的，需要**恒加 $|X|$** 把它修正为正数（因为余数不能为负）。            
- **核心逻辑**：它用“左移后加”代替了“恢复余数再左移再减”，步数固定。
# 补码除法
![[补码除法运算.png]]
![[补码除法示例.png]]
1. 第一步：预判 (初始化)
	与原码直接减不同，补码除法第一步要看**被除数 X** 和 **除数 Y** 的符号关系：
	- **同号 ($X, Y$ 符号相同)**：做 **减法**。    
	    - $[R_1]_{补} = [X]_{补} - [Y]_{补} = [X]_{补} + [-Y]_{补}$         
	- **异号 ($X, Y$ 符号不同)**：做 **加法**。    
	    - $[R_1]_{补} = [X]_{补} + [Y]_{补}$
2. 循环步骤：判别与移位 (核心口诀)    
	在中间过程中，我们比较 **当前余数 ($R_i$)** 和 **除数 ($Y$)** 的符号：
	- **判别规则 (上商)**：    
	    - **同号** ($R_i$ 和 $Y$ 符号位相同)：上商 **1**。	        
	    - **异号** ($R_i$ 和 $Y$ 符号位不同)：上商 **0**。        
	- **下一步操作 (移位 + 加减)**：    
	    - **若商了 1**：说明够减（或同号趋势），**左移**，下一次 **减除数** ($+ [-Y]_{补}$)。	        
	    - **若商了 0**：说明不够减（或异号趋势），**左移**，下一次 **加除数** ($+ [Y]_{补}$)。       

> **口诀**：**同号商 1 做减法，异号商 0 做加法。** (这里的加减指的是**下一次**的操作)

3. 结果修正：末位恒置 1
	补码除法的最后一步非常麻烦，因为商的最后一位算出来后，余数可能还需要恢复。
- **408 考点策略**：为了简化硬件设计，通常采用 **“末位恒置 1”** 法。    
- 不管最后一步算出的商是 0 还是 1，直接把商的最后一位强行变成 **1**。    
- **代价**：会有 $2^{-n}$ 的误差，但在计算机硬件实现中，这种效率提升通常优于微小的精度损失。