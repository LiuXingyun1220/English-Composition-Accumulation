# 第1章 计算机系统概述
- [ ] 冯·洛依曼结构中指令和数据如何存储？
	- 指令和数据以同等地位存放在同一个存储器中，且均以二进制形式表示。
	- 计算机能自动地根据程序计数器的指向，顺序取出指令并执行。
	*早期以**运算器**为中心，现代计算机以**存储器**为中心。*
- [ ] 冯·洛依曼计算机中，CPU如何区分指令和数据？
	CPU根据指令周期的时间阶段和数据流向来区分：
	- 指令：
		- 取值周期
		- 流向指令寄存器（IR）
		- 地址由 PC 提供
	- 数据：
		- 执行周期
		- 流向通用寄存器 / ALU
		- 地址由指令地址码提供
- [ ] 计算机可以直接识别和执行的语言是什么？【P5】
	机器语言，也称二进制代码语言。
- [ ] 硬件描述语言是什么？
	硬件描述语言（如Verilog语言，也可以看成是一种高级语言）是指可以对电子系统硬件的行为尤其是时序行为进行描述的一种编程语言，并不是指硬件可以直接执行的语言。
- [ ] 源程序转换为可执行文件的过程是什么？【P7】
- [ ] 浮点数运算指标的概念是什么？【P14】
	- MFLOPS: 每秒执行多少百万（$10^{6}$）次浮点运算。
	- GFLOPS: 每秒执行多少十亿（$10^{9}$）次浮点运算。
	- TFLOPS: 每秒执行多少万亿（$10^{12}$）次浮点运算。
	- PFLOPS: 每秒执行多少千万亿（$10^{15}$）次浮点运算。
	- EFLOPS: 每秒执行多少百京（$10^{18}$）次浮点运算。
	- ZFLOPS: 每秒执行多少十万京（$10^{21}$）次浮点运算。
	- 猫罐头配儿子
# 第2章 数据的表示与运算
- [ ] 补码加减运算后的溢出判断是如何执行的？【P41】
- [ ] 定点数的移位运算都有哪些？【P41】
	- 逻辑移位：将操作数视为无符号整数。左移时，高位移出，低位补0；右移时，低位移出，高位补0。
	- 算术移位：将操作数视为有符号整数。左移时，高位移出，低位补0；右移时，低位移出，高位补符号位。
	- 循环移位：
		- **不带进位**：移出的位，既填补空位，又送入进位标志(CF)。
		- **带进位**：把进位标志(CF)也包含在循环圈里一起转。

	- 类型转换题的“三步走”方法论
		遇到这种 `short` $\to$ `int`, `int` $\to$ `unsigned` 的题目，不要凭感觉，严格按以下三步执行：		
		- 第一步：画出“源”的二进制 (Source Bits)		
			先不管目标是什么，先把等号右边的变量（源变量）的二进制补码写出来。			
			- 如果是正数：直接转换。			    
			- 如果是负数：记得**取反加一**。	 		
		- 第二步：判断“扩展”规则 (Extension Rule)		
			这是最容易做错的一步！先保值，后变性
			- **看“源类型”**（不是看目标类型！）：			    
			    - 如果源类型是 **有符号 (signed)** $\rightarrow$ 做 **符号扩展**（前面补**符号位**，是 1 就补 1，是 0 就补 0）。			        
			    - 如果源类型是 **无符号 (unsigned)** $\rightarrow$ 做 **零扩展**（前面一律补 **0**）。			        
			    - _注：同位数转换（如 int 转 unsigned int）不需要扩展，直接拷贝比特位。_		
		- 第三步：用“模公式”求值 (Calculation)		
			得到最终的二进制串后，根据目标类型计算真值。如果数字太大不好算，直接套用公式：			
			如果最高位变成了 1，且目标是无符号数 (unsigned)，其真值等于：			
			$$2^{\text{目标位数}} - | \text{源数字的绝对值} |$$
			
			(前提是源数字是负数且进行了符号扩展)
- [ ] $ZF$, $SF$, $OF$, $CF$该如何分析？【P43】
	- $ZF$: 零标志，$ZF=1$表示结果为0。
	- $SF$: 符号标志，表示结果的符号，即$F$的最高位，对于无符号整数无意义。
	- $OF$: 溢出标志，判断有符号数运算是否溢出，$OF=C_{n} \oplus C_{n-1}$，对于无符号整数无意义。
	- $CF$: 进/借位标志，表示无符号数运算时的进位/借位，判断是否发生溢出。$CF=Sub \oplus C_{out}$。对于有符号整数无意义。
- [ ] 在乘法运算中，控制逻辑（Control Logic）的主要作用是什么？
	控制逻辑的作用可以概括为 **“判别、发令、计数”** 三大职能：	
	1. **判别 (Decision Making)**：	    
	    - 时刻监视乘数寄存器（MQ）的**最低位**（原码乘法）或 **末尾两位**（Booth 算法）。	        
	    - 根据这些位的状态（0 还是 1，01 还是 10），决定下一步是“加被乘数”、“减被乘数”还是“直接移位”。	        
	2. **发令 (Issuing Commands)**：	    
	    - 向 **ALU** 发出控制信号（如 `Add`, `Sub`）。	        
	    - 向 **寄存器（ACC, MQ）** 发出控制信号（如 `Shift Right`，`Load`）。	        
	    - 向 **多路选择器 (MUX)** 发出信号（选择把 0、X 还是 -X 送入 ALU）。	        
	3. **计数 (Counter Management)**：	    
	    - 控制一个 **计数器 (Counter)**（通常初始化为 $n$）。	        
	    - 每完成一轮“加法+移位”，计数器减 1。   
	    - 当计数器为 0 时，发出 **结束信号 (End)**，通知 CPU 乘法完成。
- [ ] 阵列乘法器相关：
	- 什么是阵列乘法器？它和普通的串行乘法器有什么本质区别？
		- **定义**：它是一种采用大量加法器和逻辑门阵列构成的**纯组合逻辑电路**。	    
		- **本质区别**：	    
		    - **串行乘法器 (Sequential)**：利用时钟信号，**分时**使用同一个加法器（做完一次加法，移位，再做下一次）。**省硬件，费时间。**	        
		    - **阵列乘法器 (Parallel/Array)**：不使用时钟节拍内部循环，而是摆开 $N \times N$ 个基本单元，**同时**产生所有部分积，并利用加法器阵列**并行**求和。**费硬件，极省时间。**
	- 阵列乘法器的工作原理是什么？（类比人脑）
		它完全模拟了人类列竖式做乘法的过程，但把每一步都“硬件化”了：	
		1. **部分积生成**：用大量的 **与门 (AND Gate)** 同时算出所有的 $x_i \times y_j$（这就好比你列竖式时写下的那几行数字）。	    
		2. **部分积求和**：用大量的 **全加器 (Full Adder)** 构成的阵列（斜向或树形结构），直接将这些部分积错位相加。  	
		- 信号像水流一样流过这些阵列，流到出口就是结果，不需要时钟去“推”它。
	- 它的优缺点是什么？
		- **优点**：**速度极快**。计算时间只取决于信号通过逻辑门的**传输延迟**（Gate Delay），通常在一个时钟周期内就能完成乘法（单周期乘法）。 
		- **缺点**：**硬件开销大，功耗高**。随着位数 $N$ 的增加，所需的逻辑门数量呈平方级增长（$N^2$）。
	- “关键路径 (Critical Path)” 在阵列乘法器中指的是什么？
		指的是信号从输入到输出所经过的**最长路径**。 这条路径经过的加法器数量最多，决定了整个乘法器的**最慢速度**。
- [ ] IEEE 754 浮点数的表示范围是多大？【P58】
	- 单精度：
		- 最小值：$e（阶码）=1，f（尾数）=0$。$1.0\times 2^{1-127}=2^{-126}$
		- 最大值：$e（阶码）=254，f（尾数）=.111\dots$。$1.111\dots 1\times 2^{254-127}=2^{127}\times(2-2^{-23})$
	-  双精度：
		- 最小值：$e（阶码）=1，f（尾数）=0$。$1.0\times 2^{1-1023}=2^{-1022}$
		- 最大值：$e（阶码）=2046，f（尾数）=.111\dots$。$1.111\dots 1\times 2^{2046-1023}=2^{1023}\times(2-2^{-52})$
- [ ] 浮点数的加减运算【P60】
	对阶；尾数加减；尾数规格化；舍入；<mark style="background: #ADCCFFA6;">溢出判断</mark>
- [ ] IEEE 754 标准中阶码全为0或全为1时，有其特别的解释。【P58】
	- 0：阶码0，尾数0；
	- 非规格化数：阶码0，尾数非0；尾数部分的形式为0.M。
	- $\infty$：阶码全1，尾数0；
	- 无定义数：阶码全1，尾数非0。
- [ ] 数据按“边界对齐”方式存储具体是指怎样的存储方式？
	在C语言的struct类型中：
	- 每个成员按其类型的大小对齐；
	- struct的长度必须是成员中最大对齐值的整数倍（不够就补全字节）。
# 第3章 存储系统
- [ ] “按字编址 (Word-Addressable)” 到底是什么意思？
	一个存储地址（门牌号）对应一个完整的“字” (Word) 的宽度。
- [ ] 在计算机组成原理中，主存（MM）完全等同于 RAM 吗？
	**不等同。**
	- 主存 = **RAM** (随机存取存储器) + **ROM** (只读存储器)。
	- RAM 是我们常说的“内存条”，用于存取动态数据
	- ROM 是主板上的固件芯片，属于主存地址空间的一部分。计算机通电瞬间，CPU 需要立即获取指令。这些“第一条指令”（引导程序）必须存放在**断电不丢失**的介质中，因此必须用 ROM。
- [ ] Cache容量计算方法是什么？
	- Cache 一行/块的容量是多少？
		- 主存物理地址
			=**Tag**           + 块内地址（全相联映射）
			=**Tag + 组号** + 块内地址（组相联映射）
			=**Tag + 块号** + 块内地址（直接映射）
		- 标记项 = 有效位1b + 标记位 Tag + （**脏位1b**）（回写法） + （**LRU替换控制位**）
		- LRU替换控制位跟组相联的路数有关：
			- $n$路组相联有$\log_{2}n$位：
			- 直接相联 $\Leftrightarrow$ 1路组相联，没有LRU替换控制位
			- 全相联 $\Leftrightarrow$ （Cache行数）路组相联
		- Cache 一行/块的容量 = 标记项 + 数据项
	- Cache的总容量是多少？
		- =Cache 行数 $\times$ Cache中一行的容量
- [ ] Cache缺失率如何计算？
	- 需要注意读和写都需要访问一次Cache。
- [ ] 缺页处理后是否需要再访问TLB，Cache不命中处理后是否需要再访问一次Cache？
	缺页处理后需要再访问一次TLB读取数据，但是Cache不命中处理过程中CPU就得到目的块了，不需要再访问一次CPU。
	这个区别的核心在于：**缺页（Page Fault）是“异常（Exception）”，需要软件介入和指令重来；而Cache缺失（Cache Miss）是“硬件阻塞（Stall）”，流水线只是暂停等待。**
- [ ] 如何计算DRAM芯片的地址引脚和数据引脚总数？（芯片的组织形式为$D \times W位$）【P86】
	- 数据引脚数$W$
	- 地址引脚数：$\lceil \frac{\log_{2}D}{2} \rceil$
- [ ] 如何安排DRAM芯片存储阵列的行数$r$和列数$c$来减少地址引脚数和刷新开销呢？（芯片阵列的组织形式为$2^{n} \times b位$）
	- 由于DRAM芯片采用地址引脚复用技术，为减少地址引脚数，应尽量使行、列位数最小，即满足$|r-c|$最小。
		- 存储阵列的地址位数为$n$，$2^{n}=r\times c$，$n=\log_{2}r+\log_{2}c$
	- 由于DRAM按行刷新，为减少刷新开销，应使行数较少，即$r\leq c$。
- [ ] Flash存储器的特点有哪些？【P88】
	- 在EPROM的基础上发展起来，它兼有ROM和RAM的优点，可在不加电的情况下长期保存信息，又能在线进行快速擦除与重写；
	- 存储元由MOS管组成，是一种非易失性存储器；
	- 位密度高于RAM；
- [ ] 交叉存储器的存取时间和带宽该如何计算？
	- 轮流启动方式
		- m体交叉存储器每个$\frac{1}{m}$存取周期可读/写一个数据，若相邻的$m$次访问的访存地址出现在同一个模块内，则会发生访存冲突，此时需延迟发生冲突的访问请求。
	- 同时启动方式
		- 所有模块一次并行读/写的总位数正好等于数据总线位数，则可以同时启动所有模块进行读/写。
		- 每次读/写的都是同一行芯片（抛开低位片选位后相同）
- [ ] 虚实地址的转换速度受什么影响？
	- TLB命中率：增大快表容量。
	- 页大小和页的级数；
	- 页表是否在内存中；
	- PIPT（Physical Index Physical Tag）VS VIPT(Virtual Index Physical Tag)
		- PIPT: 串行执行下面两步
			$VA \xrightarrow{MMU或TLB}PA$；
			用$PA$的一部分作$Index$去找$Cache$行，另一部分作$Tag$进行比。
		- VIPT: 并行执行下面两步（因为虚实地址中页内偏移量相同，若$Cache$的$Index$的位数完全落在业内偏移量的范围内，可以用VA的部分位作Index）
			$VA$中的一部分位作为$Index$，去$Cache$中定位；
			$VA\xrightarrow{TLB}PA$；
- [ ] 请给出一个简单的计算机存储器层级与材料的对应关系表。
	- **通用寄存器** $\rightarrow$ **触发器** (最快，最贵)
	- **TLB / Cache** $\rightarrow$ **SRAM** (极快，贵)
	- **主存 (Main Memory)** $\rightarrow$ **DRAM** (中等，便宜，容量大)
	- **辅存 (Disk)** $\rightarrow$ **磁性介质 / Flash** (慢，极大)
# 第4章 指令系统
- [ ] 当计算机指令的操作码位数为 7 位时，指令系统中包含单地址、二地址和三地址指令。为什么该机最多只能定义 128 条指令，而不是每种格式各 128 条（即 $128 \times 3$）呢？
	这是因为**操作码（Opcode）是指令的“唯一身份证号”**，不同格式的指令必须**共享**同一个编码空间，而不能**复用**。
- [ ] 常见的数据寻址方式、有效地址、访存次数是什么？【P169】
- [ ] CISC VS RISC(**Reduced Instruction Set Computer**)：可访存指令有哪些？通用寄存器数量哪个更多？控制方式有什么不同？哪个的指令长度是固定的？ 【P203】
- [ ] 哪些寄存器是 **可见** 的？哪些寄存器是 **不可见 (透明)** 的？
	- 可见的：
		 - **通用寄存器 (GPRs)**：如 x86 的 EAX, EBX, R0-R31 等。		    
		- **程序计数器 (PC)**：虽不能直接 `MOV`，但可以通过跳转指令修改，且程序执行依赖它，故视为可见。	    
		- **程序状态字寄存器 (PSW / FLAG)**：用于条件判断。		    
		- **基址寄存器 / 变址寄存器 (Base / Index)**：用于确定操作数地址。		    
		- **堆栈指针 (SP)**：PUSH/POP 操作依赖它。
	- 不可见的：
		- **指令寄存器 (IR)**：只存指令码，硬件自用。		    
		- **存储器地址寄存器 (MAR) & 数据寄存器 (MDR)**：CPU 和内存通信的接口，程序员无法直接控制。	    
		- **微指令层面的寄存器**：如微地址寄存器 (uMAR)。	    
		- **暂存寄存器 (Temporary Reg)**：ALU 运算过程中的中间缓冲。
# 第5章 中央处理器
- [ ] 单周期处理器的核心特性有哪些？
	- CPI=1
		-> **不能使用单总线结构**
	- 时钟周期：取决于“最慢的那个人”
		-> 处理器时钟频率较低
	- 硬件资源：拒绝复用
		-> ALU和加法器分开
		-> 指令存储器和数据存储器分开
	- 控制方式：硬布线，纯组合逻辑
		-> 无状态机
		-> 控制信号生成：指令译码后，所有的控制信号，在整个周期内同时并发生成并保持稳定
		-> 状态更新：所有的状态元素（PC、寄存器、内存）只在时钟周期的下降沿（或上升沿）到来那一瞬间统一更新。
	- 执行流程：串行化
- [ ] 数据通路的组成部件有哪些？组成数据通路的元件分为哪两类？【P219】
	- 组成部件：数据在指令执行过程中所经过的路径，包括路径上的部件，称为数据通路。ALU、通用寄存器、状态寄存器、异常和中断处理逻辑等都是指令执行时数据流经的部件。
	- 元件分类：
		- 组合逻辑元件（操作元件）
		- 时序逻辑元件（状态元件）
- [ ] 微指令后继微地址的形成方式有哪些？【P239】
	- 断定方式：由微指令的后继地址字段（也称下地址字段）指出。
	- 查表法（ROM/PLA映射法）：通过**ROM或PLA（可编程逻辑阵列）等映射部件**充当“目录”，将机器指令的**操作码**转换为控制存储器中对应的**微程序首地址**，从而实现微指令在存储空间中的**紧凑排列**（避免空间浪费）。
	- 增量计数器法：$(\mu PC)+1\to \mu PC$
	- 根据各种标志决定下一条微指令分支转移的地址。
	- 由硬件直接产生微程序的入口地址。
- [ ] 理想情况下，基本流水线CPU的CPI是多少？
	1。
- [ ] 为了利于实现指令流水线，指令集应该具有什么特征？【P255】
	- 指令长度应尽量一致，有利于简化取指令和指令译码操作。否则，取指令所花的时间长短不一，使得取指部件极其复杂，并且也不利于指令译码。
	- 指令格式应尽量规整，尽量保证源寄存器的位置相同，有利于在指令未知是就可取寄存器操作数，否则须译码后才能确定指令中各寄存器编号的位置。
	- 采用LOAD/STORE型指令，其他指令都不能访问存储器，这样可把LOAD/STORE指令的地址计算和运算指令的执行步骤规整在同一个周期中，有利于减少操作步骤。
	- 数据和指令在存储器中“按边界对齐”存放。这样，有利于减少访存次数，使所需数据在同一个流水段内就能从存储器中得到。
- [ ] 微指令的编码方式有哪些？【P238】
	- 直接编码（直接控制）方式
	- 字段直接编码方式
	- 字段间接编码方式
- [ ] load-use数据冒险如何处理？【P258】
	不能使用转发旁路技术，load指令只有在MEM段结束才能得到主存中的结果。
	解决方法：
		- 插入一条nop指令。
		- 编译优化来避免出现。
- [ ] 高级流水线技术有哪些？【P260】
- [ ] SISD、SIMD、MIMD的基本概念是什么？【P274】
	- SISD
	- SIMD：一个指令流同时对多个数据流进行处理，一般称为数据级并行技术。这种结构的计算机通常由一个指令控制部件、多个处理单元组成。
		- 变体：向量处理器
	- MIMD：同时执行多条指令分别处理多个不同的数据，分为多计算机系统（消息传递MIMD）和多处理器系统（共享存储多处理器SMP系统的简称）。

- [ ] 硬件多线程有哪三种主要实现方式？各自有什么特点？【P275】
	[[表格#^e8a1d6]]
# 第6章 总线
- [ ] 在多总线结构中，总线的速度分布有什么规律？
	**“近朱者赤，近 CPU 者快”。**
	- **CPU-内存总线**：速度最快，带宽最大（因为 CPU 吃数据最快）。
	- **PCIe/图形总线**：速度次之（显卡吞吐量大）。	    
	- **I/O 总线 (USB/SATA)**：速度较慢。
	- **扩展总线 (ISA/PCI)**：速度最慢。
- [ ] 为什么不同总线之间必须用“桥接器 (Bridge)”连接？
	**因为它们语言不通、语速不同。**
	- 桥接器的作用相当于“翻译官 + 蓄水池”。
	- **缓冲数据**：解决高速总线（如系统总线）和低速总线（如 I/O 总线）之间的速度差异。	    
	- **协议转换**：把 CPU 的控制信号转换成外设能看懂的握手信号。	    
	- **仲裁**：管理下层总线上设备的争用。
- [ ] 总线时钟频率和时钟周期的关系是什么？【P284】
	总线时钟频率：在总线中，用于定时的公共时钟信号的频率
	$\text{总线时钟频率}=\frac{1}{时钟周期}$
- [ ] 数据总线在各部件之间传输什么？【P282】
	数据、指令和中断类型号等。
- [ ] 总线带宽是什么意思？
	总线带宽指在单位时间内总线上传输的数据量。
- [ ] 影响同步总线数据传输率的因素有哪些?
	$$r = \frac{D \times N}{T_{base} + (N-1) \times T_{burst}}$$
	- **$r$**：有效数据传输率。    
	- **$D$**：数据宽度（字节）。	    
	- **$N$**：突发传输的数据个数。	    
	- **$T_{base}$**：首个数据的传输时间（含发地址、延迟等）。	    
	- **$T_{burst}$**：后续每个数据的传输时间（通常即为时钟周期）。
	
	- 总线时钟频率:**总线长度**越长，信号传播延迟越大，允许的**最高时钟频率就越低**。
	- 总线宽度 / 数据通路宽度 ($W$)
	- 每个时钟周期传输的次数 (数据传输模式)
		- **单边沿触发 (SDR)**：只在时钟的**上升沿**传输一次数据。
		- **双边沿触发 (DDR)**：在时钟的**上升沿**和**下降沿**各传输一次数据。
	- 传输效率与协议开销:
		- **地址/数据复用**：如果总线采用地址线和数据线复用，传输一次数据需要“先传地址，再传数据”，这会分摊有效时间，降低传输率。
		- **等待周期 (Wait States)**：同步总线虽然按节拍走，但如果从设备（如慢速内存）跟不上主设备的速度，必须插入**等待周期（Ready 信号无效）**。等待周期越多，有效传输率越低。
		- **突发传输 (Burst Mode)**：
			- **单次传输**：每次都要发地址 $\rightarrow$ 读数据。			    
			- **突发传输**：发一次地址 $\rightarrow$ 连续读出 $N$ 个数据。突发传输能显著提高有效传输率。
	
- [ ] 总线事务有哪些方式？【P291】
- [ ] 总线传输有哪些方法？
	- 串行传输：按位逐位传输。
	- 并行传输：多位数据位同时在设备之间传输。
	- 同步传输：传输过程由统一时钟控制。
	- 突发传输：在一次总线事务中，主设备只需给一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据的传输。
- [ ] 总线定时都有哪些方式，这些方式都有什么特点？【P291】
	- 同步定时方式：系统采用一个**统一**的时钟信号来协调发送和接收双方的传送定时关系
	- 异步定时方式：
		根据“请求”和“回答”信号的撤销是否互锁，异步定时方式又分为以下3种类型：
		- 不互锁方式
		- 半互锁方式：主设备发出“请求”信号后，必须在接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系。而从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁
		- 全互锁方式		
	- 半同步定时方式：例如，某个半同步总线总是从某个时钟开始，在每个时钟到来时，采样Wait信号，若无效，则说明数据未准备好，下个时钟到来时，再采样Wait信号，直到检测到有效，再去数据线上取数据。
	- 分离式定时方式
- [ ] 同步总线中，传输时间如何计算？
	- 典型步骤：传地址（通常1个周期）；存取/延时（设备准备数据需要时间）；传数据（通常1个周期）
- [ ] 在异步串行通信中，传输一个字符（一帧）的总位数公式是什么？
	异步总线采用握手的方式进行通信，每次握手的过程完成一次通信，但一次通信往往会交换多位而非一位数据
	$$总位数 = 起始位 + 数据位 + 校验位 + 停止位$$
	- **起始位**：用于通知接收端开始传输（通常为逻辑0），固定为**1位**。
	- **数据位**：实际传输的有效数据（如ASCII码或字节）。
	- **校验位**：用于检错（奇/偶校验），可选。
	- **停止位**：表示一帧结束（通常为逻辑1）。
# 第7章 输入/输出系统
- [ ] 如何快速通过“名字”来判断是I/O接口还是I/O设备？
	- **是接口 (Interface)**：名字里通常带有 **“适配器” (Adapter)**、**“控制器” (Controller)**、**“卡” (Card)**、**“接口”**。    
	    - _例子_：显示适配器（显卡）、网络控制器（网卡）、USB 接口、**可编程中断控制器**（它是负责管理和缓冲中断信号的芯片，连接在 CPU 和外设之间，属于 I/O 接口系统的一部分（控制接口））。
	- **是设备 (Device)**：名字里通常是具体的**物理器具**或**驱动器**。    
	    - _例子_：键盘、鼠标、显示器、**磁盘驱动器**、打印机。
- [ ] I/O 数据传输全景流程图
	![[IO 数据传输全景流程图.png]]
- [ ] I/O端口的定义是什么？【P302】
	I/O接口电路中可被CPU直接访问的寄存器，主要有数据端口、状态端口和控制端口。
- [ ] 中断处理过程【P309】
	[[Mermaid图#^54d390|一个可嵌套中断的典型流程]] ^1def12
	CPU在执行一条指令过程中检测异常事件。
- [ ] 中断处理保存断点这一步，将什么保存在栈或特定寄存器中？【P310】
	由专门的硬件（中断隐指令）保存原程序的断点（指令无法直接读取的PC和PSW的内容）。
- [ ] “中断响应”和“中断处理”有什么区别？【P312】
	- **中断响应 (Interrupt Response)**：是 **硬件** 做的原子操作。
		- 时机：指令执行周期的最后。
		- 动作：关中断、保护断点 (PC)、引出中断服务程序入口地址（向量）。	
		- **核心动作**：    
		    1. **关中断**：硬件自动将中断允许标志位 (IF) 置 0。        
		    2. **保护断点**：硬件自动将 **PC** (和 PSW) 压入堆栈。        
		    3. **引出向量**：硬件根据中断号，查询中断向量表，找到服务程序的入口地址。        
		- **此时决定的优先级：响应优先级 (Response Priority)**  
		    - **定义**：当**多个中断同时**到来时，硬件逻辑决定先响应哪一个。        
		    - **特点**：**固定不变**（由硬件排队电路或查询顺序决定）。      
		    - **场景**：打印机和磁盘同时发来请求，硬件决定先理磁盘。
	- **中断处理 (Interrupt Handling)**：是 **软件**（OS 代码）做的。	
		  - 动作：保护现场（通用寄存器）、执行业务逻辑、恢复现场。
		  - **核心动作**：    
		    1. **保护现场**：软件指令将 **通用寄存器** (GPRs) 压栈。        
		    2. **设置屏蔽字 & 开中断**：(实现多重中断的关键)。        
		    3. **执行服务**：真正的业务逻辑（如读取数据）。   
		    4. **关中断 & 恢复现场**。        
		    5. **中断返回**：`IRET` 指令。        
		- 此时决定的优先级：处理优先级 (Handling Priority)
		    - **定义**：一个中断**正在处理**时，是否允许被另一个中断打断（实现嵌套）。        
		    - **特点**：**动态可变**（通过软件修改 **中断屏蔽字 IMR** 来改变）。        
		    - **场景**：正在处理磁盘中断（高响应优先级），但我不希望被打断，所以我屏蔽了所有其他中断。此时它的处理优先级最高。
- [ ] 
- [ ] DMA方式的传送过程是什么？
	![[DMA的传送流程.png|814x649]]
	DMA传送前由设备驱动程序设置传送参数。
- [ ] 适合采用 DMA 输入输出的设备有哪些？
	- 适合：网卡和固态硬盘
	- 不适合：键盘和针式打印机
- [ ] DMA方式和中断方式有什么区别呢？【P317】
	1. 核心本质：
		- **软硬之分**：中断靠**程序**（软件，CPU执行指令）传送；DMA靠**硬件**（DMA控制器）传送。
		- **资源之争**：中断请求的是**CPU时间**（处理时间）；DMA请求的是**总线使用权**。
		- **干预程度**：中断全程需 **CPU 干预**；DMA 传送过程 **不需 CPU 干预**（挂起 CPU，硬件直接拷贝）。
	2. 响应时机与优先级：
		- 响应点：对中断请求的响应发生在每条指令执行结束后（**指令周期**后）；对DMA请求的响应可以发生在存取周期结束时（**机器周期**后）。
		- 优先级：DMA > 中断
	3. 过程与功能：
		- 现场保护：中断是程序切换，**需要**保护现场；DMA 只是借用总线，**不需要**保护现场（仅需预处理/后处理）。
		- 应用场景：中断方式具有处理异常事件的能力，而DMA方式仅局限于大批数据的传送（选择型DMA控制器 $\to$  不适用于慢速设备；多路型DMA控制器 $\to$ 同时为多个慢速外围设备服务）。
# 其他
- [ ] 已知屏幕分辨率、色深、帧频，怎么求显示存储器中DRAM进行刷新所需的带宽？
	$\text{刷新所需带宽}=\text{屏幕分辨率}\times\text{色深}\times\text{帧频}$
- [ ] 系统调用、外部中断和缺页等事件都是发生在用户态的，具体过程是在内核态执行的。进程切换属于系统调用执行过程中的事件，只能发生在内核态。
- [ ]  double型变量占多少个字节？
	8B。
- [ ] 什么是时钟脉冲信号？它是如何产生的？
	时钟脉冲信号是计算机工作的基准时间信号。它通常由机器脉冲源（如晶体振荡器）发出的脉冲信号，经过**整形**（使波形更规整）和**分频**（调整频率）后形成。
- [ ] 时钟周期的长度是可以随意设置的吗？以什么为基准？
	不可以。
	时钟周期必须足够长，以保证信号能从一个寄存器通过组合逻辑电路稳定地传播到下一个寄存器。因此，它以**相邻状态单元间组合逻辑电路的最大延迟**（即关键路径的延迟）为基准确定。如果周期太短，电路逻辑还没运算完，下一个信号就来了，会导致错误。
- [ ] CPU 的时间计量单位有哪些层级？它们之间有何联系？
	从大到小依次为：
	1. **指令周期 (Instruction Cycle)**：CPU 从内存取出并执行完一条指令所需的全部时间。
    2. **机器周期 (Machine Cycle)**：也称 CPU 周期。指令执行过程被划分为若干个阶段（如取指、译码、访存等），每个阶段通常需要一个或多个机器周期。通常以内存读取一个字的最短时间来定义。
    3. **时钟周期 (Clock Cycle)**：最基本的节拍。
	**关系**：一个指令周期包含若干机器周期，一个机器周期包含若干时钟周期。
- [ ] 为什么说“处理器总是在每来一个时钟脉冲信号时就开始执行一条新的指令”是错误的？
	- **多周期执行**：大多数现代 CPU 的指令极其复杂，无法在一个时钟周期内完成。执行一条指令通常需要多个时钟周期（即 CPI > 1）。
    - **流水线技术**：虽然在理想的流水线处理器中，可以做到“每个时钟周期**完成**一条指令”（Throughput），但这并不意味着每个脉冲都**开始并执行完**一条全新指令。且存在流水线停顿等情况。
    - **正确理解**：时钟脉冲驱动的是微操作（如寄存器传输、ALU计算），而不是整条指令的宏观执行。
- [ ] 机器字长 vs 指令字长 vs 存储字长
	[[表格#^2b6abf]]
- [ ] 在微操作 $M(MAR) \rightarrow MDR$ 中，为什么只有 `Read` 信号，而没有 `MDRin` 信号？
	1. 数据的来源不同 (两扇门理论)
		MDR (数据缓冲寄存器) 作为 CPU 和主存的“中转站”，它通常有两个输入端口：		
		- **端口 A (面向 CPU 内部)**：连接 **CPU 内部总线**。用于接收通用寄存器或 ALU 的数据（如 $R0 \rightarrow MDR$）。这个端口的控制信号通常叫 **`MDRin`** (或 `MDRin_Bus`)。		    
		- **端口 B (面向主存)**：连接 **系统数据总线 (External Data Bus)**。用于接收主存读出的数据。这个通路的开启通常由 **`Read`** 信号触发的时序逻辑自动控制，或者由一个专门的 **`MDRin_Mem`** (外部输入) 信号控制。    	
	2. 信号定义的约定 (考研习惯)	
		在大多数教材和 408 考试的约定中：		
		- **`MDRin`**：特指 **“将 CPU 内部总线上的数据打入 MDR”**。		    
		- **`Read`**：特指 **“启动存储器读，并将数据通过外部总线送入 MDR”**。		    
		- **结论**：这是一个约定俗成的**分工**。`Read` 指令隐含了“打开外部数据通路并锁存到 MDR”的动作，所以不需要（也不能）写 `MDRin`，否则会造成总线冲突（以为你要从内部总线读数据）。
	3. 避免总线冲突
		- 如果你同时有效 `Read` (外部数据进来) 和 `MDRin` (内部数据进来)，MDR 就会同时收到两路数据，导致电路短路或数据错误。