# 第1章 绪论
- [ ] 数据的逻辑结构有哪些？【P2】
	- 集合
	- 线性结构
	- 树形结构
	- 图状结构或网状结构
# 第3章 栈、队列和数组
- [ ] 压缩存储是什么？【P101】
	指为多个值相同的元素只分配一个存储空间，对零元素不分配空间。
	注意是按行优先存储还是按列优先存储。
- [ ] 三对角矩阵（也称带状矩阵）是什么样的？【P103】
- [ ] 采用非递归方式重写递归程序时必须使用栈，这句话对吗？
	错误。有可以使用循环结构/动态规划的。
- [ ] 三元组表是什么？【P104】
	（行标$i$，列标$j$，值$a_{i,j}$），适合稀疏矩阵的压缩存储。
- [ ] 请绘制出所有相关链表的图示。
	![[链表图示.png]]
	+ 静态链表：用数组来描述线性表的链式存储结构。
	
# 第4章 串
- [ ] KMP算法（字符串的下标从1开始）中，next数组的推理公式是是什么？【P115】
	```C++
	// KMP算法主体，next数组
	int kmp(const string& s1, const string& s2) {
	    int n = s1.length();
	    int m = s2.length();
	
	    // 边界处理：空模式串通常返回0，或者根据具体题目要求
	    if (m == 0){
	    	return 0;
	    }
	
	    // s1中当前比对的位置是x
	    // s2中当前比对的位置是y
	    int x = 0, y = 0;
	
	    // O(m) 生成next数组，直接填充到全局变量 next_arr 中
	    getNextArray(s2, m);
	
	    // O(n) 匹配过程
	    while (x < n && y < m) {
	        if (s1[x] == s2[y]) {
	            x++;
	            y++;
	        }
	        else if (y == 0) {
	            // 如果y已经在0位置还匹配不上，x只能往下走
	            x++;
	        }
	        else {
	            // y回退
	            y = next_arr[y];
	        }
	    }
	
	    // 如果y走到了m，说明匹配成功，返回起始位置
	    return y == m ? x - y : -1;
	}
	
	// 计算next数组
	void getNextArray(const string& s, int m) {
	    // 单独处理 m=1 的情况
	    if (m == 1) {
	        next_arr[0] = -1;
	        return;
	    }
	    next_arr[0] = -1;
	    next_arr[1] = 0;
	
	    // i表示当前要求next值的位置
	    // cn表示当前要和前一个字符比对的下标 (也代表前缀长度)
	    int i = 2;
	    int cn = 0;
	
	    while (i < m) {
	        if (s[i - 1] == s[cn]) {
	            // 配上了，cn+1，赋值给next[i]，然后i自增
	            next_arr[i++] = ++cn;
	        }
	        else if (cn > 0) {
	            // 没配上，且cn还能往前跳
	            cn = next_arr[cn];
	        }
	        else {
	            // 没配上，且cn已经跳到0了
	            next_arr[i++] = 0;
	        }
	    }
	}
	
	//优化
	void getNextValArray(const string& s, int m) {
    if (m == 1) {
        next_arr[0] = -1;
        return;
    }

    next_arr[0] = -1;
    
    // 【优化点1】初始化 index 1 时也需要判断是否与 s[0] 相同
    if (s[1] == s[0]) {
        next_arr[1] = -1; 
    } else {
        next_arr[1] = 0;
    }

    int i = 2;
    int cn = 0; 
    // 注意：如果上面改了 next_arr[1] 为 -1，这里的 cn 初始值逻辑其实
    // 应该对应 next[1] 的"原始长度值"(即0)。
    // 但在循环中，cn 代表的是"当前前缀长度"，
    // 只要保证 cn 能够正确回退即可。
    // 为保持代码结构简单，建议此处 cn 依然从 0 开始，
    // 但逻辑上我们依赖循环内的回退机制。

    while (i < m) {
        if (s[i - 1] == s[cn]) {
            // 匹配成功，cn 长度加 1
            cn++;
            
            // 【优化点2】赋值前的判断
            if (s[i] == s[cn]) {
                // 如果当前位置 s[i] 和回退后的位置 s[cn] 字符相同，
                // 那么跳到 cn 也没用（肯定还会失配），
                // 直接继承 cn 的 nextval 值
                next_arr[i] = next_arr[cn];
            } else {
                // 如果不同，才记录当前的长度 cn
                next_arr[i] = cn;
            }
            i++;
        }
        else if (cn > 0) {
            // 没配上，继续往前跳
            // 注意：这里使用的是已经计算好的 nextval 数组进行回跳，
            // 这会加速回跳过程
            cn = next_arr[cn];
        }
        else {
            // cn 跳到 0 也没配上
            // 【优化点3】同样需要判断 s[i] 是否等于 s[0]
            if (s[i] == s[0]) {
                 next_arr[i] = -1; // 或者 next_arr[0]
            } else {
                 next_arr[i] = 0;
            }
            i++;
        }
    }
}
	```
	
# 第5章-树与二叉树
- [ ] 已知完全二叉树在第k层（根结点在第0层）的叶结点数，如何推其最多有多少个结点？
	第k层为树的倒数第二层时，该完全二叉树的结点数最多。
- [ ] 线索二叉树【P145】
- [ ] 前缀编码是什么？
	- 若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码。
- [ ] 假设森林 F 与二叉树 T 可以相互转换，二者结点之间有何关系呢？
	- F中的叶子节点 $\Leftrightarrow$ T中左孩子为空的结点
	- F中没有右兄弟$\Leftrightarrow$ T中右孩子为空的结点 
	- T的叶节点 $\Leftrightarrow$ F中既是叶节点，又没有右兄弟的结点
- [ ] 数和森林的遍历与其对应转换的二叉树遍历的关系是什么？【P175】
	[[表格#^622d97|总结表格]] ^a570ea
	
# 第6章 图
- [ ] 邻接矩阵如何表示呢？【P206】
	- 1代表存在边，0代表不存在边。
	- 带权图：用0或$\infty$代表不存在边。
- [ ] 邻接链表的存储结构如何定义？【P208】
	```C++
	#define MaxVertexNum 100	//图中顶点数目的最大值
	typedef struct ArcNode {	//边表结点
		int adjvex;	//该弧所指向的顶点的位置
		struct ArcNode* nextarc;	//指向下一条弧的指针
		//InfoType info;	//网的边权值
	}ArcNode;
	typedef struct VNode {
		VertexType data;
		ArcNode* firstarc;
	}VNode,AdjList[MaxVertexNum];
	typedef struct {
		AdjList vertices;
		int vexnum, arcnum;
	}ALGraph;

	```
- [ ] 十字链表是什么？【P209】
	有向图的一种链式存储结构。
	- 弧结点结构：
		- $i$（行），$j$（列）
		- $down$（指向同列的下一个非零元素），$right$（指向同行的下一个非零元素）
		- $info$
	- 顶点结点结构（顺序存储）：
		- $data$
		- $down$(以该顶点为弧头的第一条弧)
		- $right$（以该顶点为弧尾的第一条弧）
- [ ] BFS算法性能分析
	- 空间复杂度：$O(|V|)$，每个顶点都需要入队一次
	- 时间复杂度：
		- 邻接表：$O(|V|+|E|)$
		- 邻接矩阵：$O(|V|^2)$
- [ ] DFS算法的性能分析：
	- 空间复杂度：$O(|V|)$，递归工作栈
	- 时间复杂度：
		- 邻接表：$O(|V|+|E|)$
		- 邻接矩阵：$O(|V|^2)$
- [ ] 最小生成树【P231】
- [ ] MST形状唯一的判定依据是什么？
	- 充分条件：
		- 带权连通图中，所有边的权值都互不相同。
		- 带权连通图的任意一个环中，所包含的边的权值均不相同。
- [ ] 对于无向图$G=(V,E)$，当$|V|<|E|$时，$G$一定是连通的吗？
	不是。反例见下图，图中，$|V|=5$，$|E|=6$，但$G$不连通。
	![[反例图.png|333x215]]
- [ ] 最短路径一定是简单路径吗？
	是
- [ ] Dijkstra算法适合求任意两个顶点的最短路径吗？
	适合。
- [ ] Floyd-Warshall 算法的核心思想和算法流程是什么？【P236】
	- 核心思想：**“如果我经过节点 $k$ 中转，能不能缩短节点 $i$ 到节点 $j$ 的距离？”**
		它基于**动态规划**的思想。我们要尝试将图中的每一个节点 $k$ ($k=1 \dots n$) 依次作为“中转站”放入图中，看看能不能优化现有的路径。
		- 状态转移方程（必背公式）：$$D[i][j] = \min(D[i][j], \quad D[i][k] + D[k][j])$$
			$D[i][j]$：目前已知的从 $i$ 到 $j$ 的最短距离。 
			$D[i][k] + D[k][j]$：从 $i$ 先走到 $k$，再从 $k$ 走到 $j$ 的距离。
	- 算法流程：三层循环
		1. **初始化**：    
		    - 建立一个二维矩阵 $D$（也就是邻接矩阵）。	        
		    - $D[i][j]$ = 边权 $w_{ij}$（如果有边）。		        
		    - $D[i][j] = \infty$（如果无边）。		        
		    - $D[i][i] = 0$。		        
		2. **三层循环遍历**（注意顺序！）：		    
		    - **第一层（最外层）**：枚举**中转点** $k$。   
		    - **第二层**：枚举**起点** $i$。		        
		    - **第三层**：枚举**终点** $j$。
		- 代码模板：
			```C++
			// 假设 n 是节点数量，adj 是邻接矩阵
			void floyd(int n) {
			    // k 必须在最外层
			    for (int k = 0; k < n; k++) {          // 枚举中转点
			        for (int i = 0; i < n; i++) {      // 枚举起点
			            for (int j = 0; j < n; j++) {  // 枚举终点
			                // 防止溢出，只有当两条路都通的时候才比较
			                if (D[i][k] != INF && D[k][j] != INF) {
			                    if (D[i][k] + D[k][j] < D[i][j]) {
			                        D[i][j] = D[i][k] + D[k][j]; // 更新最短路径
			                        // Path[i][j] = k; // 如果需要记录路径，记录中转点
			                    }
			                }
			            }
			        }
			    }
			}
			```
- [ ] 关键路径和关键活动指什么？【P240】
	- 关键路径是指从源点到汇点的所有路径中，具有最大路径长度的路径称，关键路径上的活动称为关键活动。
	- 关键路径不一定只有一条，但所有关键路径的长度是相同的。
	- 增大某个关键活动，会使关键路径长度变大。
	- 减小某个关键活动，不一定会使关键路径长度减小，因为此时该路径不一定再继续满足关键路径的定义。
	- 若AOE网中存在多条长度相同的关键路径，只有同时减小当前所有关键路径上边的长度，才能减小关键路径长度，从而使AOE网对应的工程提前。
- [ ] 活动完成的时间余量如何计算？【P241】
	边$<v_{k},v_{j}>$表示活动$a_{i}$
	- 活动$a_{i}$的最早开始时间$e(i)=v_{e}(k)$
	- 活动$a_{i}$的最迟开始时间$l(i)=v_{l}(j)-Weight(v_{k},v_{j})$
	- 活动$a_{i}$完成的时间余量$d(i)=l(i)-e(i)$
# 第7章-查找
- [ ] 折半查找判定树的性质是什么？【P273】
	- 是AVL。
	- 只有最下面两层可能不满。
	- 树的高度：$H=\lceil \log_{2}(n+1) \rceil或\lfloor \log_{2}n \rfloor+1$
	- 左右子树的节点数规律：右子树要么和左子树一样多，要么比左子树多（or 少）1个结点。
- [ ] 平衡二叉树的插入及删除【P287】
	- 插入每次调整的对象都是最小不平衡子树
	- 平衡二叉树的插入：
		- LL平衡旋转（右单旋转）
		- RR平衡旋转（左单旋转）
		- LR 平衡旋转（先左后右双旋转）
		- RL平衡旋转（先右后左双旋转）
- [ ] B树和B+树【P311】

- [ ] 开放定址法 $H_{i}=(H(key)+d_{i})\%m$ 中的增量序列$d_{i}$有哪些取法？【P325】
	- 线性探测法（也称线性探测再散列法）：$d_{i}=1,2,\dots,m-1$。
	- 平方探测法（也称二次探测法）：$d_{i}=1^{2},-1^{2},2^{2},-2^{2},\dots,k^{2},-k^{2}，其中k\leq \frac{m}{2}$；散列表长度$m$必须是一个可以表示成$4k+3$的素数。
	- 双散列法：
		$d_{i}=i\times Hash_{2}(key)$，
		$H_{i}=(H(key)+i\times Hash_{2}(key))\%m$
	- 伪随机序列法：$d_{i}=伪随机数序列$
- [ ] 散列表中，同义词指什么？
	在散列（哈希）方法中，[同义词](https://csgraduates.com/data_structure/search/hash/#%e5%90%8c%e4%b9%89%e8%af%8d) 是指不同的元素通过哈希函数映射到同一个哈希值（或哈希地址)。这意味着这些元素在散列表中会发生冲突，因为它们试图占用相同的位置。
- [ ] 如何分析散列表的查找效率？即分析散列表查找成功/失败的平均查找长度？【P326】
	- 查找成功：散列表有$n$个元素，则分别计算这$n$个元素查找成功时的查找次数，最后将这些查找次数相加再除以$n$。
	- 查找失败：散列表的模数为$x$，则分别统计散列到地址$0\sim x-1$处的比较次数，最后将这些查找次数相加再除以$n$。
	- 在计算 **查找失败的平均查找长度 ($ASL_{miss}$)** 时：带有“删除标记”的格子，在查找失败的过程中，依然被视为“非空”格子。
- [ ] 影响散列表查找的因素有哪些？【P327】
	散列函数、处理冲突的方法和装填因子。
- [ ] 散列表中的装填因子是什么意思？
	$\text{装填因子}\alpha=\frac{\text{表中记录数}n}{\text{散列表长度}m}$

# 第8章 排序
- [ ] 希尔排序（又称缩小增量排序）【P341】
- [ ] 快速排序的代码模板是什么？【P348】
	```cpp
	#include <iostream>
	#include <cstdlib>
	#include <algorithm>
	#include <random>
	using namespace std;
	
	#define endl '\n'
	
	int N;
	const int MAXN = 1e5 + 10;
	int a[MAXN];
	int first, last;
	
	void swap(int pos1, int pos2) { 
		int temp = a[pos1];
		a[pos1] = a[pos2];
		a[pos2] = temp;
	}
	
	// 荷兰国旗划分函数
	void partition(int l, int r, int x) {
		first = l, last = r; // first之前为小于x，last之后为大于x
		int i = l;
		while (i <= last) {
			if (a[i] < x) {
				swap(i, first);
				first++;
				i++;
			}
			else if (a[i] > x) {
				swap(i, last);
				last--;
			}
			else { // 如果等于x，直接跳过
				i++;
			}
		}
	}
	
	// 快速排序的主函数
	void quickSort(int l, int r) {
		if (l >= r) { // 改为l >= r，终止条件更合理
			return;
		}
	
		int x = a[l + rand() % (r - l + 1)];
	
		// 划分数组
		partition(l, r, x);
		quickSort(l, first - 1);
		quickSort(last + 1, r);
	}
	
	signed main() {
		ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	
		cin >> N;
		for (int i = 0; i < N; i++) {
			cin >> a[i];
		}
	
		quickSort(0, N - 1);
	
		cout << a[0];
		for (int i = 1; i < N; i++) {
			cout << " " << a[i];
		}
		cout << endl;
	
		return 0;
	}
	```
- [ ] 快速排序中**枢轴（Pivot/基准元素）的归位特性**是什么？
	- 位置归位：每经过一趟排序，至少有一个元素（枢轴）被放置在了它**最终有序**的位置上。
    - 大小分区：枢轴左边的所有元素都比它小，右边的所有元素都比它大。
    - 层级逻辑：第二趟排序是对第一趟产生的子序列进行处理。如果第一趟的枢轴将数组分为两半，那么第二趟结束时，左右子序列中应各有一个枢轴归位（共3个归位，含第一趟的）。如果第一趟枢轴在一端，第二趟则处理剩下的一长串（共2个归位）。
- [ ] 构建初始堆的操作流程是什么？【P359】
	- 建堆思路：从后（第$\left\lfloor  \frac{n}{2}  \right\rfloor$个结点）往前检查所有分支结点，看是否满足堆的要求，若不满足，则对以该分支结点为根的子树进行调整。
- [ ] 实现多关键字排序有哪些方法？【P372】
	- 最高位（MSD）优先法，按关键字位权重递减依次逐层划分成若干更小的子序列，最后将所有子序列依次连接成一个有序序列
	- 最低位（LSD）优先法，按关键字位权重递增依次进行排序，最后形成一个有序序列。
- [ ] 不稳定的排序算法有哪些？【P381】
	简单选择排序、希尔排序、快速排序、堆排序
- [ ] 败者树【P389】
	- [ ] 为什么要引入败者树？它解决了什么问题？
		它是为了优化 **$k$ 路归并排序** 的性能。	
		- **问题**：如果不使用树结构，在 $k$ 个归并段中找一个最小值，需要比较 $k-1$ 次。	    
		- **解决**：使用败者树，可以将查找最小值的比较次数降低到 **$\lceil \log_2 k \rceil$** 次。	    
		- **场景**：主要用于**外部排序**。因为磁盘 I/O 很慢，内存计算相对快，但当 $k$ 很大时，内部比较的时间也会成为瓶颈，败者树就是用来消除这个瓶颈的。
	- [ ] 败者树的节点里存的是什么？
		**存的是“失败者”的索引（来自哪个归并段）。**	
		- **胜者 (Winner)**：通常指数值**较小**的那一方（因为我们要从小到大排序，小的先输出）。	    
		- **败者 (Loser)**：数值**较大**的那一方。	    
		- **规则**：	    
		    - 每个非叶子节点记录其两个子节点比赛后的**败者**（较大的那个）。	        
		    - 而**胜者**（较小的那个）则继续向上层参加比赛。	        
		    - 最终的**总冠军**（全局最小值）的索引记录在树的顶端（通常是 `ls[0]`）。
	- [ ] 当输出一个最小值后，败者树如何“调整”？
		这是一个 **自底向上** 的过程：	
		1. 输出当前最小值的元素。	    
		2. 从该元素所属的归并段读取下一个元素进来。	    
		3. **从叶子节点开始往根节点走**：	    
		    - 拿新进来的元素 X 与父节点记录的“旧败者” Y 进行比较。	        
		    - **胜者继续向上**：较小的那个数继续往上层走。        
		    - **败者留在原地**：较大的那个数的索引留在这个父节点中（更新父节点）。        
		4. 一直比到根节点，新的总冠军诞生。
	- [ ] 败者树的复杂度是多少？
		假设有 $k$ 路归并：	
		- **建树时间**：$O(k)$。
		- **调整时间（输出一个数）**：$O(\log_2 k)$。	    
		- **空间复杂度**：需要一个数组 `ls[0...k]` 来存储败者索引，空间为 $O(k)$。
- [ ] 置换-选择排序（生成初始归并段）的核心流程【P389】
	维护一个内存工作区（通常用**最小堆**或**败者树**组织）：
	1. **初始化**：把工作区填满。	    
	2. **选出最小**：从工作区选出最小值 `MIN`。	    
	3. **输出**：把 `MIN` 写到当前归并段，并记录为 `LAST_OUT`（最近输出的一个数）。	    
	4. **置换 (输入)**：从外存读入下一个数 `NEW`，填补 `MIN` 留下的空位。	    
	5. **判断 (关键)**：	    
	    - **若 `NEW` $\ge$ `LAST_OUT`**：说明 `NEW` 可以接在当前归并段后面（没破坏递增顺序），放入堆中继续参与筛选。	        
	    - **若 `NEW` < `LAST_OUT`**：说明 `NEW` 比刚才输出的数还小，**它绝对不能放在当前归并段里**（否则就乱序了）。	        
	        - **处理**：把它视为 **“死元素” (Frozen)**，暂存在内存里，但不参与当前的筛选，留给**下一个**归并段用。	            
	6. **循环**：直到工作区里**全都是“死元素”**，当前归并段结束。开启新的一段，复活所有元素。
- [ ] 如何计算实现最佳归并时需要补充的虚段的数量？【P391】
	- 最佳归并树是严格k叉树，即只有度为0和度为k的结点；
	- $n=n_{0}+n_{k}=k \times n_{k}+1 \Rightarrow n_{0}-1=(k-1)n_{k}$
	- 故，要实现最佳归并，需要添加适当数量的虚段，使其加上初始归并段的数量后再减1，可以被$(k-1)$整除。
# 其他
- [ ] 遇到难以计算的题目，该怎么办？
	- 考虑特殊解。
# 综合应用题答题思路
## 算法题思路
### 注意点
- [ ] 如何初始化一个全为非0数的数组？
	利用`for`循环完成。
	`memset`/`{1}`都是错误的。
### 链表
#### 快慢指针
```C++
	while (fast->next != NULL) {
		slow = slow->next;
		fast = fast->next;
		if (fast->next != NULL)
			fast = fast->next;
	}
```
### 树
#### 对于顺序存储的二叉树，如何判断其为二叉搜索树？
中序遍历判断其是否为“升序序列”。
### 排序
#### 求数组中最小/最大的k个元素
堆排序
### 原地算法
概念：原地算法不需要额外的数据结构就能变换输入数据的[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95 "算法")。不过，分配少量空间给部分辅助变量是被允许的。
#### 三次逆置实现数组循环左移
```C++
// start和end表示需要倒置的开始位置和结束位置
void reverse(int R[], int start, int end) {
	int temp;// 作为交换的临时变量
	for (int i = 0; i < (end - start + 1) / 2; i++) {//将首尾位置的元素交换
		temp = R[start + i];
		R[start + i] = R[end - i];
		R[end - i] = temp;
	}
}

void move(int R[], int p, int n) {
	reverse(R, 0, n - 1);
	reverse(R, 0, n - p - 1);
	reverse(R, n - p, n - 1);
}
```
#### 查找数组中出现次数超过 $\frac{n}{2}$ 的元素
```C++
/**
 * 算法功能：查找数组中出现次数超过 n/2 的元素
 * (Boyer-Moore 投票算法，空间复杂度 O(1))
 */
int majorityElement_BoyerMoore(int A[], int n) {
    int candidate = A[0]; // 候选人
    int count = 0;        // 票数

    // 1. 遍历数组，找出候选人
    for (int i = 0; i < n; i++) {
        if (count == 0) {
            // 票数为0，更换候选人
            candidate = A[i];
        }
        
        if (A[i] == candidate) {
            count++; // 相同则加票
        } else {
            count--; // 不同则减票 (抵消)
        }
    }
    
    // 2. 验证候选人（如果题目保证一定存在多数元素，此步可省略）
    // count = 0;
    // for (int i = 0; i < n; i++) {
    //     if (A[i] == candidate) {
    //         count++;
    //     }
    // }
    // if (count > n / 2) {
    //     return candidate;
    // }
    // return -1; // 示例：表示未找到

    // 题目通常保证多数元素存在，直接返回候选人
    return candidate;
}
```
## 简答题思路
- [ ] 提出一种新的解决方法，问是否可行？
	- 不可行，进行举例说明：
		1. 指明反例的具体条件和求解结果；
		2. 按照题目方法，求得结果为：……；（一句话总结）
		3. 实际正确结果为：……（与上一步结果不同）；
		4. 进行简单的分析
- [ ] 